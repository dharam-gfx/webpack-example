### Full Example Without and With Webpack: Side-by-Side Comparison

I'll show you how to structure a project both **without Webpack** and **with Webpack**. This will help you understand the difference in how code is managed and bundled.

---

## Without Webpack

### Project Structure

```bash
webpack-example-no-webpack/
├── dist/
│   └── index.html  # Main HTML file linking to JS files directly
├── src/
│   ├── math.js     # Utility functions
│   ├── module.js   # Dynamically loaded module
│   └── index.js    # Main entry point
└── .gitignore
```

### 1. **Source Files (Without Webpack)**

#### `src/math.js`
This file contains utility functions that can be directly used in the browser.

```javascript
// src/math.js
function add(a, b) {
  return a + b;
}

function subtract(a, b) {
  return a - b;
}

function multiply(a, b) {
  return a * b;
}

function divide(a, b) {
  return a / b;
}

// Expose functions 
export const MathUtils = { add, subtract, multiply, divide };
```

#### `src/module.js`
This file will be dynamically loaded using a `<script>` tag when needed.

```javascript
// src/module.js
function greet() {
  console.log('Hello from dynamically loaded module!');
}

// Expose greet globally
window.GreetModule = { greet };
```

#### `src/index.js`
This is the main entry point that directly interacts with the browser DOM.

```javascript
// src/index.js
import { MathUtils } from "./math.js";
document.getElementById('load-module').addEventListener('click', function () {
    // Dynamically load module.js using <script> tag
    const script = document.createElement('script');
    script.src = '../src/module.js';
    console.log(script);
    
    document.body.appendChild(script);
  
    script.onload = function () {
      GreetModule.greet(); // Call the function after the script is loaded
    };
  });
  
  console.log(`5 + 10 = ${MathUtils.add(5, 10)}`);
  console.log(`5 * 10 = ${MathUtils.multiply(5, 10)}`);
  console.log(`5 * 10 = ${MathUtils.multiply(5, 10)}`);
  console.log(`multiply fun =`, MathUtils.multiply);
```

#### `dist/index.html`
The HTML file manually includes all the necessary scripts.
<br/>
Run `dist/index.html` in your browser via **Live-Server** or other.

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>No Webpack Example</title>
</head>
<body>
  <h1>Check Console for Output!</h1>
  <button id="load-module">Load Module</button>

  <!-- Load main JS file and math utilities -->
  <script type="module" src="../src/math.js"></script>
  <script type="module" src="../src/index.js"></script> <!-- Main entry point -->

  <!-- module.js will be dynamically loaded in index.js -->
</body>
</html>
```

### How it works:
- You manually manage `<script>` tags to include `math.js` and `index.js`.
- When the user clicks the "Load Module" button, `module.js` is dynamically loaded with a `<script>` tag.

### Problems:
- **No Minification**: The files aren't optimized.
- **No Tree Shaking**: All code from `math.js` is loaded, even if not used.
- **No Code Splitting**: All scripts are loaded upfront, even unused ones.
  
---

## With Webpack

### Project Structure

```bash
webpack-example-with-webpack/
├── dist/
│   ├── index.html         # Main HTML file (bundled JS will be included automatically)
│   ├── main.bundle.js     # Main bundle generated by Webpack
│   └── src_module_js.chunk.js  # Dynamically loaded module chunk
├── src/
│   ├── math.js            # Utility functions (tree-shakable)
│   ├── module.js          # Dynamically loaded module
│   └── index.js           # Main entry point
├── package.json           # NPM setup with Webpack
├── webpack.config.js       # Webpack config file
└── .gitignore
```

### Step-by-Step Example

### 1. ** Install Webpack and Dependencies**

In your new project folder, run:

```bash
cd test-webpack-installation
npm init -y
npm install webpack webpack-cli --save-dev
```

### 1. **Source Files (With Webpack)**

#### `src/math.js`
Same utility functions but using ES6 modules, enabling **tree shaking**.

```javascript
// src/math.js
export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}

export function multiply(a, b) {
  return a * b;
}

export function divide(a, b) {
  return a / b;
}
```

#### `src/module.js`
The module that will be dynamically loaded with Webpack's **code splitting**.

```javascript
// src/module.js
export function greet() {
  console.log('Hello from dynamically loaded module!');
}
```

#### `src/index.js`
This is the main entry point that imports only used functions and loads the `module.js` dynamically.

```javascript
// src/index.js
import { add, multiply } from './math';  // Tree shaking removes unused imports

console.log(`5 + 10 = ${add(5, 10)}`);
console.log(`5 * 10 = ${multiply(5, 10)}`);

// Dynamically load the module with Webpack's import()
document.getElementById('load-module').addEventListener('click', () => {
  import('./module').then(module => {
    module.greet();  // Loaded dynamically
  });
});
```

### 2. **Webpack Configuration**

#### `webpack.config.js`
The configuration for bundling, enabling **tree shaking**, **minification**, and **code splitting**.

```javascript
const path = require('path');

module.exports = {
  mode: 'production',  // Enables minification and tree shaking
  entry: './src/index.js',  // Main entry point
  output: {
    filename: 'main.bundle.js',  // Output file
    chunkFilename: '[name].chunk.js',  // For dynamic imports
    path: path.resolve(__dirname, 'dist'),  // Output directory
  },
  optimization: {
    usedExports: true,  // Tree shaking: removes unused code
  },
};
```

### 3. **Run Webpack**

In your `package.json`, add the Webpack build script:

```json
{
  "name": "webpack-example-with-webpack",
  "version": "1.0.0",
  "scripts": {
    "build": "webpack"
  },
  "devDependencies": {
    "webpack": "^5.0.0",
    "webpack-cli": "^4.0.0"
  }
}
```

Run the following command to bundle the files:

```bash
npm run build
```

### 4. **HTML File**

#### `dist/index.html`
This file includes the **bundled** JavaScript file generated by Webpack. <br/>
Run `dist/index.html` in your browser via **Live-Server** or other.

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Webpack Example</title>
</head>
<body>
  <h1>Check Console for Webpack Output!</h1>
  <button id="load-module">Load Module</button>

  <!-- Include Webpack's bundled JS file -->
  <script src="main.bundle.js"></script>
</body>
</html>
```

### What Happened:
- **Minification**: The `main.bundle.js` is automatically minified due to `production` mode.
- **Tree Shaking**: Only the used functions (`add` and `multiply`) from `math.js` are included in the final bundle.
- **Code Splitting**: The `module.js` is not loaded until the button is clicked, reducing the initial load time.

---

### Summary of Differences

| Without Webpack                         | With Webpack                                         |
|-----------------------------------------|-----------------------------------------------------|
| Manual management of script files       | Webpack automatically bundles and optimizes files   |
| No minification or code optimization    | Minification and tree shaking enabled by default    |
| Scripts loaded upfront (even unused)    | Code splitting ensures modules load on demand       |
| Manual handling of dynamic imports      | Webpack handles dynamic imports using `import()`    |

### Why Use Webpack?
- **Minified and Optimized Code**: Webpack automatically removes unused code and minimizes file sizes.
- **Tree Shaking**: Removes unused imports, optimizing the final bundle size.
- **Code Splitting**: Only loads what is necessary, improving performance.
- **Modular Code**: Webpack allows you to organize your code into modules without worrying about script order or global scope issues. 

By using Webpack, your project becomes more maintainable, scalable, and optimized for production.